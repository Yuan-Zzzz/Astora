{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Astora Engine","text":"<p>Warning</p> <p>The editor is built by AI!!!! Just for test some features,DO NOT USE IT NOW!!!!.It will be deleted in the future, and rewrite by human code!</p>"},{"location":"#what-is-astora-engine","title":"What is Astora Engine","text":"<p>The Astora Engine is designed to enhance the development efficiency of game developers.  It focuses on 2D game development, uses the C# programming language, and is built on MonoGame.</p> <p>Warning</p> <p>Astora Engine now is building with my own game.That means it will bring broken changes</p>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Its design philosophy lies in enabling quick switching between two modes: pure code development and editor-based development.</p> <p>So you can use Astora Engine to build your own game with pure C# code. Then you can use editor to do some visual edit. After using the editor, you can completely abandon it and continue developing solely through pure code.</p>"},{"location":"#who-is-suitable","title":"Who is suitable?","text":"<ul> <li>Skilled C# Programmer</li> <li>Basic knowledge of MonoGame/FNA/XNA</li> <li>Prefers pure code (occasional visual editor aid)</li> <li>Focusing on GameDev, Not for Tools</li> </ul>"},{"location":"#give-feedback","title":"Give Feedback","text":"<p>If you discover any issue with the documentation and the engine. You can create an issue on Github;</p>"},{"location":"contributing/code-style/","title":"Code Style","text":""},{"location":"contributing/code-style/#overall-principles","title":"Overall Principles","text":"<ul> <li>Keep code simple, readable, and maintainable.</li> <li>Prioritize API stability and backward compatibility.</li> <li>Program to interfaces/abstractions and minimize module coupling.</li> </ul>"},{"location":"contributing/code-style/#project-structure","title":"Project Structure","text":"<ul> <li>Core: Engine core (rendering, scenes, nodes, etc.)</li> <li>Editor: Visual editor (ImGui, tool panels, etc.)</li> <li>SandBox: Sample and development project</li> <li>Document: Documentation and site</li> </ul>"},{"location":"contributing/code-style/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Classes, interfaces, enums: PascalCase; interfaces prefixed with I (e.g. <code>ISceneSerializer</code>).</li> <li>Methods, properties, events: PascalCase.</li> <li>Fields:</li> <li>Public fields: PascalCase.</li> <li>Private fields: <code>_camelCase</code> (underscore prefix).</li> <li>Local variables and parameters: camelCase.</li> <li>Constants: PascalCase</li> <li>Names should express intent; avoid abbreviations and ambiguous names.</li> </ul>"},{"location":"contributing/code-style/#files-and-namespaces","title":"Files and Namespaces","text":"<ul> <li>Keep namespace and directory structure aligned, e.g. <code>Astora.Core.Nodes</code> corresponds to <code>Astora.Core/Nodes/</code>.</li> <li>Put each public type in its own file; file name should match the type name.</li> </ul>"},{"location":"contributing/code-style/#code-formatting","title":"Code Formatting","text":"<ul> <li>Use .editorconfig or IDE default C# conventions (4-space indentation, UTF-8).</li> <li>Braces on new lines:</li> <li>Place <code>{</code> on a new line for classes/methods/control statements.</li> <li>Use expression-bodied members only when they improve readability.</li> <li>Avoid excessively long lines (recommendation: no more than 120 columns).</li> </ul>"},{"location":"contributing/code-style/#api-design","title":"API Design","text":"<ul> <li>Prefer immutability or minimal mutability.</li> <li>Write XML documentation comments for public APIs.</li> </ul>"},{"location":"contributing/code-style/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Use imperative verbs in commit messages describing the change, for example: <code>Add SpriteFrames loader</code>.</li> <li>Link issues/PRs and provide a brief description of the change and motivation.</li> </ul>"},{"location":"contributing/code-style/#example-snippet","title":"Example Snippet","text":"<pre><code>namespace Astora.Core.Nodes\n{\n    public class Node\n    {\n        private int _updateOrder;\n\n        public int UpdateOrder =&gt; _updateOrder;\n\n        public void AddChild(Node child)\n        {\n            // ...\n        }\n    }\n\n    public interface INode\n    {\n\n    }\n}\n</code></pre>"},{"location":"core-concepts/architecture/","title":"Architecture","text":"<p>Warning</p> <p>This document is a work in progress and may be updated frequently.</p>"},{"location":"core-concepts/architecture/#overview","title":"Overview","text":"<p>Astora Engine is node-based, meaning that everything in the engine is represented as a node in a tree structure. This allows for a highly modular and flexible design, where different components can be easily added, removed, or modified without affecting the overall system. This is inspired by Godot Engine's architecture.</p>"},{"location":"core-concepts/architecture/#engine","title":"Engine","text":"<p>The Engine class is the main entry point of Astora Engine. It is responsible for initializing and managing the various subsystems of the engine, such as rendering, input handling, audio, and more. The Engine class also provides a way to access global settings and configurations for the engine.</p> <p>Features of the Engine class include:</p> <ul> <li>Managing the main game loop, including updating and rendering.</li> <li>Providing a centralized input handling system.</li> <li>Designing resolution and display settings.</li> </ul>"},{"location":"core-concepts/architecture/#node-system","title":"Node System","text":"<p>Node System is the core of Astora Engine. It provides a way to create and manage nodes, which can represent various elements such as scenes, objects, scripts, and more. Nodes can have parent-child relationships, allowing for hierarchical organization and inheritance of properties and behaviors. In Astora Engine, everything is a node, including scenes, objects, scripts, and even the engine itself. This allows for a consistent and unified approach to managing different components of the engine.</p>"},{"location":"core-concepts/node/node-and-scene-tree/","title":"Node and SceneTree","text":"<p>One of the core concepts is SceenTree, which is the hierarchy of nodes.</p>"},{"location":"core-concepts/node/node-and-scene-tree/#what-is-node","title":"What is Node?","text":"<p>Node is the most basic block in creating game entity.Everything is a node in scene.A node contains a Parent and a list of Children.It builds a tree structure.</p>"},{"location":"core-concepts/node/node-and-scene-tree/#what-is-sceentree","title":"What is SceenTree?","text":"<p>A Scene Tree is the structure you build out of nodes. A scene has a single \"root\" node,and all other nodes are descendants of it. This hierarchical structure is powerful: - Organization: Group related nodes together. For example, a <code>Player</code> node might have a       <code>Sprite</code> and a <code>Camera2D</code> as its children. - Relative Transformations: A child node's position, rotation, and scale are relative toits parent. If you move the parent, all its children move with it, maintaining their relativpositions. AttributeTargets.Field</p>"},{"location":"core-concepts/render-pipeline/intro/","title":"Intro","text":""},{"location":"core-concepts/render-pipeline/intro/#render-pipeline","title":"Render Pipeline","text":"<p>The Render Pipeline is a core module of the Astora Engine, what is is the manager of all rendering operations. It is deal rendering automatically, and it is highly customizable through the use of Render Passes and other settings.</p>"},{"location":"core-concepts/render-pipeline/intro/#base-structure","title":"Base Structure","text":"<pre><code>graph TD\n    A[**Engine**&lt;br/&gt;Core of Astora, Manage any part of the engine] --&gt; B[**RenderPipeline**&lt;br/&gt;Manager of rendering operations] \n    B --&gt; C[**RenderBatcher**&lt;br/&gt;Manager of render batches, based on SpriteBatch]</code></pre>"},{"location":"core-concepts/render-pipeline/render-batcher/","title":"RenderBatcher","text":"<p>RenderBatcher is the encapsulation of MonoGame's SpriteBatch in Astora Engine. It provides a higher-level interface for managing render batches, making it easier to deal with some rendering operations.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#about-spritebatch","title":"About SpriteBatch","text":"<p>The SpriteBatch is a batch processing system of MonoGame that allows you to draw multiple sprites with a single draw call, improving rendering performance. It uses Begin/End methods to define a batch of sprites which will be drawn together. Here is the basic usage of SpriteBatch:</p> <pre><code>spriteBatch.Begin(...Something Parameters...);\nspriteBatch.Draw(...);\nspriteBatch.Draw(...);\n...\nspriteBatch.End();\n</code></pre> <p>When you call <code>Begin</code>, the SpriteBatch will set up some necessary states for rendering, such as the transformation matrix, the blend state, and the sampler state. This allows you to draw your sprites with the correct settings without having to change these states manually for each draw call. And when you call <code>End</code>, the SpriteBatch will flush all the sprites that have been drawn since the last <code>Begin</code> call to the graphics device in a single draw call.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#talk-about-transform-matrix","title":"Talk about Transform Matrix","text":"<p>We mentioned the transformation matrix in the previous section. So, what is it?</p> <p>Imagine there is a canvas, and a rect is located at (50,100) on this canvas. If we move up the rect by 10 units, and then move right by 20 units. Eventually, the point will be located at (70,90). Same as scaling and rotation, we can translate the rect attributes to achieve the same effect. However, here comes the problem. There are too many ways to transform a rect, and if we want to combine multiple transformations, it will become very complicated. This is where the transformation matrix comes in. A transformation matrix is a mathematical tool that can represent multiple transformations in a single matrix.</p> <p>By using matrix multiplication, we can combine multiple transformations into a single matrix. For example, if we want to first translate the rect by (20,-10), then scale it by 2 times, and finally rotate it by 45 degrees, we can create three separate matrices for each transformation and then multiply them together to get a single transformation matrix. This matrix can then be applied to the rect to achieve the desired transformation.</p> <p>So you can see that the transformation matrix is a magic box that can transform positions, scales, and rotations all at once.</p> <p>Warning</p> <p>I think this part should be in the article about Camera, but just a reminder here.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#why-renderbatcher","title":"Why RenderBatcher?","text":"<p>While SpriteBatch is powerful, using it directly faces limitations on state management. </p> <p>When you call <code>SpriteBatch.Begin()</code>, the rendering states (BlendState, SamplerState, Effect, TransformMatrix, etc.) are set for the entire batch. </p> <p>Imagine a situation, you are drawing a scene with multiple sprites. They have the same rendering states, for example, all using AlphaBlend. Suddenly, you need to draw some particles with Additive blend state, or apply a special shader effect to a character sprite. You can't switch the modes in the middle of a batch simply.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#the-problem-manual-state-management","title":"The Problem: Manual State Management","text":"<p>So without a manager, everything that is drawn needs to manage the rendering lifecycle itself. A simple implementation may look like this:</p> <pre><code>//It's in ParticleSystem render loop\n// 1. We have to interrupt the global batch because we need Additive blending\nspriteBatch.End(); \n// 2. Start a new batch with our specific settings\nspriteBatch.Begin(SpriteSortMode.Deferred, BlendState.Additive, ..., globalTransform);\n// 3. Draw our particles\nforeach(var p in particles) spriteBatch.Draw(...);\n// 4. End our batch\nspriteBatch.End();\n// 5. RESTORE the original batch for the next object? \nspriteBatch.Begin(..., BlendState.AlphaBlend, ...);\n</code></pre> <p>So here comes the problem:</p> <ul> <li>We have to manually manage the batch lifecycle, which is error-prone and tedious.</li> <li>If not managed carefully, you might accidentally break batches too often, increasing draw calls significantly.</li> <li>GameObjects need to know too much about the global rendering context (like the Camera's View Matrix), but it's unnecessary for them to be aware of these details.</li> </ul>"},{"location":"core-concepts/render-pipeline/render-batcher/#the-solution-renderbatcher","title":"The Solution: RenderBatcher","text":"<p>RenderBatcher is designed to solve these problems by managing multiple render batches automatically. It allows different parts of your rendering code to request specific rendering states without worrying about the underlying batch management.</p> <p>We just need to call RenderBatcher.Draw with the desired settings, and the RenderBatcher will take care of starting and ending batches as needed. This way, you can focus on what to draw rather than how to manage the drawing process.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#what-is-renderbatcher","title":"What is RenderBatcher?","text":"<p>The answer is simple: It's a state machine for SpriteBatch.</p> <p>At its core, RenderBatcher is the middleware between your rendering code and the SpriteBatch. You just need to tell your RenderBatcher what to draw and with which settings. No more <code>Begin</code>/<code>End</code> calls, just draw directly.</p> <p>RenderBatcher tracks the current rendering state internally.  - _currentTransformMatrix: The current transformation matrix applied to all sprites. - _currentBlendState: The current blend state for rendering. - _currentSamplerState: The current sampler state for textures. - _currentEffect: The current shader effect applied to sprites.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#how-it-works","title":"How it Works","text":"<p>When you call <code>RenderBatcher.Draw</code>, it performs a quick check:</p> <ul> <li>Checks requested states and compares them with current states.</li> <li>If they match, it simply draws the sprite using the existing batch.</li> <li>If they differ, it ends the current batch (if any), updates the states, and starts a new batch with the requested settings.</li> </ul>"},{"location":"core-concepts/render-pipeline/render-pipeline/","title":"RenderPipeline","text":"<p>The RenderPipeline is the manager of the rendering process. It is designed to solve these problems by organizing the rendering process into a modular, linear workflow.</p>"},{"location":"core-concepts/render-pipeline/render-pipeline/#why-renderpipeline","title":"Why RenderPipeline?","text":"<p>MonoGame provides a powerful rendering method, We can clear the screen and draw sprites in a absolute positon. However, this approach has some limitations:</p> <ul> <li>Lack of Modularity: The rendering process is often tightly coupled with game logic, making it difficult to manage and extend.</li> <li>Difficult to Customize: Customizing the rendering process (e.g., adding post-processing effects, handling multiple cameras) can be cumbersome and error-prone.</li> <li>State Management Issues: Managing rendering states (like blend modes, shaders, etc.) can become complex, especially when different objects require different states.(Fortunately, we have RenderBatcher to help us manage the states.)</li> </ul>"},{"location":"core-concepts/render-pipeline/render-pipeline/#how-renderpipeline-works","title":"How RenderPipeline Works?","text":"<p>The RenderPipeline operates by processing a series of rendering commands in a specific order. Each stage of the pipeline is responsible for a particular task, such as culling, sorting, or applying post-processing effects. This separation of concerns makes it easier to manage the rendering process and implement new features.</p> <p>At it's core, the RenderPipeline is Pass-based. It's a list of passes. We render them in sequence. Each Pass represents a distinct phase in the rendering process. For example, you might have passes for:</p> <ul> <li>Scene Rendering</li> <li>Post-Processing</li> <li>UI Rendering</li> </ul> <p>You can customize the RenderPipeline by adding, removing, or modifying passes to suit your game's needs.</p> <pre><code>Engine.RenderPipeline.AddPass(new SceneRenderPass());  //Render the Game Scene  \nEngine.RenderPipeline.AddPass(new PostProcessPass());  //Apply Post-Processing Effects\nEngine.RenderPipeline.AddPass(new UIRenderPass());     //Render the User Interface\nEngine.RenderPipeline.AddPass(new FinalCompositionPass()); //Compose the Final Image\n</code></pre> <p>Warning</p> <p>This document is a work in progress and may be updated frequently.</p>"},{"location":"core-concepts/render-pipeline/render-pipeline/#default-renderpipeline","title":"Default RenderPipeline","text":"<p>Astora Engine comes with a built-in pipeline configuration to get you standard immediately.By default,thie pipeline contains two core passes that act like  the \"bread\" of the sandwich,holding your rendering process together.</p> <ul> <li> <p>SceneRenderPass: It iterates through the active scene tree and draws all visable nodes. It applies the View Matrix provided by the active camera. This ensures that when the camera moves, the world moves relative to it. It draws the result onto an internal.</p> </li> <li> <p>FinalCompositionPass: It takes the rendered result from the previous passes and draws it to the actual screen back-buffer.It applies a Scale Matrix to fit the virtual resolution to the actual window size,handling aspect ratios and letterboxing automatically.</p> </li> </ul> <p>RenderTarget(Visual Canvas)</p>"},{"location":"core-concepts/render-pipeline/render-pipeline/#visual-resolution-handling","title":"Visual Resolution Handling","text":"<p>On of the biggest challenges in 2D game development is supporting various screen sizes and aspect ratios.Astora solves this using a Virtual Resolution System.</p> <p>You define a logical resolution for your game(e.g. 1920x1080).All your game logic, coordinates,and sprites position are baesd on this fixed resolutiuon.The RenderPipeline draws everything to an internal RenderTarget that matches your Design Resolution.</p>"},{"location":"core-concepts/render-pipeline/render-pipeline/#ping-pong-buffering","title":"Ping-Pong Buffering","text":"<p>Warning</p> <p>TODO</p>"}]}