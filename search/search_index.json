{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Astora Engine","text":""},{"location":"#what-is-astora-engine","title":"What is Astora Engine","text":"<p>The Astora Engine is designed to enhance the development efficiency of game developers.  It focuses on 2D game development, uses the C# programming language, and is built on MonoGame.</p> <p>Astora Engine now is building with my own game.That means it will bring broken changes</p>"},{"location":"#desgin-philosophy","title":"Desgin Philosophy","text":"<p>Its design philosophy lies in enabling quick switching between two modes: pure code development and editor-based development. </p> <p>So you can use Astora Engine to build your own game whit pure C# code.Then you can use editor to do some visual edit.After using the editor, you can completely abandon it and continue developing solely through pure code.</p>"},{"location":"#who-is-suitable","title":"Who is suitable?","text":"<ul> <li>Skilled C# Programmer</li> <li>Basic knowledge of MonoGame/FNA/XNA</li> <li>Prefers pure code (occasional visual editor aid)</li> <li>Focusing on GameDev, Not for Tools</li> </ul>"},{"location":"#give-feedback","title":"Give Feedback","text":"<p>If you discover any issue whit the documentation and the engine.You can create an issue on Github;</p>"},{"location":"Blog/2026-1-08%20Something%20Progress%20on%20MSDF%20Rendering/","title":"Something Progress on MSDF Rendering","text":"<p>This is mainly because when I was developing with MonoGame, there was a lack of libraries that offer good support for SDF text rendering. Therefore, I tried to build one myself. Currently, some progress has been made: I can successfully render MSDF (Multi-channel Signed Distance Field) maps, and they can also be scaled up or down without loss of quality.  This will serve as an underlying function of the engine, facilitating support for text rendering or other more exciting features in the future.</p> <p>Here is the simple shader code I used for rendering MSDF maps:</p> <pre><code>#if OPENGL\n#define SV_POSITION POSITION\n#define VS_SHADERMODEL vs_3_0\n#define PS_SHADERMODEL ps_3_0\n#else\n#define VS_SHADERMODEL vs_4_0_level_9_3\n#define PS_SHADERMODEL ps_4_0_level_9_3\n#endif\n\nTexture2D SpriteTexture;\n\nsampler2D SpriteTextureSampler = sampler_state\n{\n    Texture = &lt;SpriteTexture&gt;;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : SV_POSITION;\n    float4 Color : COLOR0;\n    float2 TextureCoordinates : TEXCOORD0;\n};\n\nfloat pxRange;\nfloat2 textureSize;\nfloat4 bgColor;\nfloat4 fgColor;\n\nfloat median(float r, float g, float b)\n{\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat4 MainPS(VertexShaderOutput input) : COLOR\n{\n    float2 coord = input.TextureCoordinates;\n    float2 msdfUnit = pxRange / textureSize;\n    float3 samp = (tex2D(SpriteTextureSampler, coord) * input.Color).rgb;\n    float sigDist = median(samp.r, samp.g, samp.b) - 0.5;\n    sigDist *= dot(msdfUnit, 0.5 / fwidth(coord));\n    float opacity = clamp(sigDist + 0.5, 0, 1);\n    return lerp(bgColor, fgColor, opacity);\n}\n\ntechnique SpriteDrawing{\n    pass P0{\n        PixelShader = compile PS_SHADERMODEL MainPS();\n    }\n}\n;\n</code></pre>"},{"location":"Features/Rendering/SDF/","title":"SDF","text":""}]}