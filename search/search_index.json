{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Astora Engine","text":""},{"location":"#what-is-astora-engine","title":"What is Astora Engine","text":"<p>The Astora Engine is designed to enhance the development efficiency of game developers.  It focuses on 2D game development, uses the C# programming language, and is built on MonoGame.</p> <p>Warning</p> <p>Astora Engine now is building with my own game.That means it will bring broken changes</p>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Its design philosophy lies in enabling quick switching between two modes: pure code development and editor-based development.</p> <p>So you can use Astora Engine to build your own game with pure C# code. Then you can use editor to do some visual edit. After using the editor, you can completely abandon it and continue developing solely through pure code.</p>"},{"location":"#who-is-suitable","title":"Who is suitable?","text":"<ul> <li>Skilled C# Programmer</li> <li>Basic knowledge of MonoGame/FNA/XNA</li> <li>Prefers pure code (occasional visual editor aid)</li> <li>Focusing on GameDev, Not for Tools</li> </ul>"},{"location":"#give-feedback","title":"Give Feedback","text":"<p>If you discover any issue with the documentation and the engine. You can create an issue on Github;</p>"},{"location":"contributing/code-style/","title":"Code Style","text":""},{"location":"contributing/code-style/#overall-principles","title":"Overall Principles","text":"<ul> <li>Keep code simple, readable, and maintainable.</li> <li>Prioritize API stability and backward compatibility.</li> <li>Program to interfaces/abstractions and minimize module coupling.</li> </ul>"},{"location":"contributing/code-style/#project-structure","title":"Project Structure","text":"<ul> <li>Core: Engine core (rendering, scenes, nodes, etc.)</li> <li>Editor: Visual editor (ImGui, tool panels, etc.)</li> <li>SandBox: Sample and development project</li> <li>Document: Documentation and site</li> </ul>"},{"location":"contributing/code-style/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Classes, interfaces, enums: PascalCase; interfaces prefixed with I (e.g. <code>ISceneSerializer</code>).</li> <li>Methods, properties, events: PascalCase.</li> <li>Fields:</li> <li>Public fields: PascalCase.</li> <li>Private fields: <code>_camelCase</code> (underscore prefix).</li> <li>Local variables and parameters: camelCase.</li> <li>Constants: PascalCase</li> <li>Names should express intent; avoid abbreviations and ambiguous names.</li> </ul>"},{"location":"contributing/code-style/#files-and-namespaces","title":"Files and Namespaces","text":"<ul> <li>Keep namespace and directory structure aligned, e.g. <code>Astora.Core.Nodes</code> corresponds to <code>Astora.Core/Nodes/</code>.</li> <li>Put each public type in its own file; file name should match the type name.</li> </ul>"},{"location":"contributing/code-style/#code-formatting","title":"Code Formatting","text":"<ul> <li>Use .editorconfig or IDE default C# conventions (4-space indentation, UTF-8).</li> <li>Braces on new lines:</li> <li>Place <code>{</code> on a new line for classes/methods/control statements.</li> <li>Use expression-bodied members only when they improve readability.</li> <li>Avoid excessively long lines (recommendation: no more than 120 columns).</li> </ul>"},{"location":"contributing/code-style/#api-design","title":"API Design","text":"<ul> <li>Prefer immutability or minimal mutability.</li> <li>Write XML documentation comments for public APIs.</li> </ul>"},{"location":"contributing/code-style/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Use imperative verbs in commit messages describing the change, for example: <code>Add SpriteFrames loader</code>.</li> <li>Link issues/PRs and provide a brief description of the change and motivation.</li> </ul>"},{"location":"contributing/code-style/#example-snippet","title":"Example Snippet","text":"<pre><code>namespace Astora.Core.Nodes\n{\n    public class Node\n    {\n        private int _updateOrder;\n\n        public int UpdateOrder =&gt; _updateOrder;\n\n        public void AddChild(Node child)\n        {\n            // ...\n        }\n    }\n}\n</code></pre>"},{"location":"core-concepts/architecture/","title":"Architecture","text":"<p>Warning</p> <p>This document is a work in progress and may be updated frequently.</p>"},{"location":"core-concepts/architecture/#overview","title":"Overview","text":"<p>Astora Engine is node-based, meaning that everything in the engine is represented as a node in a tree structure. This allows for a highly modular and flexible design, where different components can be easily added, removed, or modified without affecting the overall system. This is inspired by Godot Engine's architecture.</p>"},{"location":"core-concepts/architecture/#engine","title":"Engine","text":"<p>The Engine class is the main entry point of Astora Engine. It is responsible for initializing and managing the various subsystems of the engine, such as rendering, input handling, audio, and more. The Engine class also provides a way to access global settings and configurations for the engine.</p> <p>Features of the Engine class include:</p> <ul> <li>Managing the main game loop, including updating and rendering.</li> <li>Providing a centralized input handling system.</li> <li>Designing resolution and display settings.</li> </ul>"},{"location":"core-concepts/architecture/#node-system","title":"Node System","text":"<p>Node System is the core of Astora Engine. It provides a way to create and manage nodes, which can represent various elements such as scenes, objects, scripts, and more. Nodes can have parent-child relationships, allowing for hierarchical organization and inheritance of properties and behaviors. In Astora Engine, everything is a node, including scenes, objects, scripts, and even the engine itself. This allows for a consistent and unified approach to managing different components of the engine.</p>"},{"location":"core-concepts/render-pipeline/intro/","title":"Intro","text":""},{"location":"core-concepts/render-pipeline/intro/#render-pipeline","title":"Render Pipeline","text":"<p>The Render Pipeline is a core module of the Astora Engine, what is is the manager of all rendering operations. It is deal rendering automatically, and it is highly customizable through the use of Render Passes and other settings.</p>"},{"location":"core-concepts/render-pipeline/intro/#base-structure","title":"Base Structure","text":"<pre><code>graph TD\n    A[**Engine**&lt;br/&gt;Core of Astora, Manage any part of the engine] --&gt; B[**RenderPipeline**&lt;br/&gt;Manager of rendering operations] \n    B --&gt; C[**RenderBatcher**&lt;br/&gt;Manager of render batches, based on SpriteBatch]</code></pre>"},{"location":"core-concepts/render-pipeline/render-batcher/","title":"RenderBatcher","text":"<p>RenderBatcher is the encapsulation of MonoGame's SpriteBatch in Astora Engine. It provides a higher-level interface for managing render batches, making it easier to deal some rendering operations.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#about-spritebatch","title":"About SpriteBatch","text":"<p>The SpriteBatch is a batch processing system of MonoGame that allows you to draw multiple sprites with a single draw call, improving rendering performance. It use Begin/End methods to define a batch of sprites which will be drawn together.Here is the basic usage of SpriteBatch:</p> <pre><code>spriteBatch.Begin(...Something Parameters...);\nspriteBatch.Draw(...);\nspriteBatch.Draw(...);\n...\nspriteBatch.End();\n</code></pre> <p>When you call <code>Begin</code>, The Sprite Batch will set up some necessary states for rendering, such as the transformation matrix, the blend state, and the sampler state. This allows you to draw your sprites with the correct settings without having to change these states manually for each draw call.And whe you call <code>End</code>,The Sprite Batch will flush all the sprites that have been drawn since the last <code>Begin</code> call to the graphics device in a single draw call.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#talk-about-transform-matrix","title":"Talk about Transform Matrix","text":"<p>We mentioned the transformation matrix in the previous section. So what it is?</p> <p>Imagine here is a canvas, and a rect is located at (50,100) on this canvas. If we move up the rect by 10 units, and then move right by 20 units. Eventually, the point will be located at (70,90). Same as scaling and rotation, we can use translate the rect attributes to achieve the same effect. However, here comes the problem,. There are too many ways to transform a rect, and if we want to combine multiple transformations, it will become very complicated. This is where the transformation matrix comes in. A transformation matrix is a mathematical tool that can represent multiple transformations in a single matrix.</p> <p>By using matrix multiplication, we can combine multiple transformations into a single matrix. For example, if we want to first translate the rect by (20,-10), then scale it by 2 times, and finally rotate it by 45 degrees, we can create three separate matrices for each transformation and then multiply them together to get a single transformation matrix. This matrix can then be applied to the rect to achieve the desired transformation.</p> <p>So you can see that the transformation matrix is a magic box that can transform positions, scales, and rotations all at once.</p> <p>Warning</p> <p>I think the part should be in artical about Camera, but just remind here.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#why-renderbatcher","title":"Why RenderBatcher?","text":"<p>While SpriteBatch is Powerful, using it directly is facing a limitation on state management. </p> <p>When you call <code>SpriteBatch.Begin()</code>, the rendering states(BlendState, SamplerState, Effect, TransformMatrix, etc.) are set for the entire batch. </p> <p>Imagining a situation, you are drawing a scene with multiple sprites. They have the same rendering states, like all the blend state is AlphaBlend.Suddenly, you need to draw some particles with Additive blend state, or apply a special shader effect to a chraracter sprite.you can't switch the modes in the middle of a batch simply.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#the-problem-manual-state-management","title":"The Problem: Manual State Management","text":"<p>So without a manager, everything what will be drawn needs to manage the rendring lifecycle itself. A simplest implementation may look like this:</p> <pre><code>//It's in ParticleSystem render loop\n// 1. We have to interrupt the global batch because we need Additive blending\nspriteBatch.End(); \n// 2. Start a new batch with our specific settings\nspriteBatch.Begin(SpriteSortMode.Deferred, BlendState.Additive, ..., globalTransform);\n// 3. Draw our particles\nforeach(var p in particles) spriteBatch.Draw(...);\n// 4. End our batch\nspriteBatch.End();\n// 5. RESTORE the original batch for the next object? \nspriteBatch.Begin(..., BlendState.AlphaBlend, ...);\n</code></pre> <p>So here comes the problem: - We have to manually manage the batch lifecycle, which is error-prone and tedious. - If not managed carefully, you might accidentally break batches too often, increasing draw calls significantly. - GameObject need to know too much about the global rendering context (like the Camera's View Matrix), but it's unnecessary for them to be aware of these details.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#the-solution-renderbatcher","title":"The Solution: RenderBatcher","text":"<p>RenderBatcher is designed to solve these problems by managing multiple render batches automatically. It allows different parts of your rendering code to request specific rendering states without worrying about the underlying batch management.</p> <p>We just need to call RenderBatcher.Draw with the desired settings, and the RenderBatcher will take care of starting and ending batches as needed. This way, you can focus on what to draw rather than how to manage the drawing process.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#what-is-renderbatcher","title":"What is RenderBatcher?","text":"<p>The answer is simple: It's a state machine for SpriteBatch.</p> <p>At its core, RenderBatcher is the middleware between your rendering code and the SpriteBatch. You just need to tell your RenderBatcher what to draw and with which settings. No more the <code>Begin</code>/<code>End</code> calls, just draw directly.</p> <p>RenderBatcher tracks the current rendering state internally.  - _currentTransformMatrix: The current transformation matrix applied to all sprites. - _currentBlendState: The current blend state for rendering. - _currentSamplerState: The current sampler state for textures. - _currentEffect: The current shader effect applied to sprites.</p>"},{"location":"core-concepts/render-pipeline/render-batcher/#how-it-works","title":"How it Works","text":"<p>When you call <code>RenderBatcher.Draw</code>, it deal a fast check:</p> <ul> <li>Check requested and compare with current states.</li> <li>If they match, it simply draws the sprite using the existing batch.</li> <li>If they differ, it ends the current batch (if any), updates the states, and starts a new batch with the requested settings.</li> </ul>"}]}