using System.Reflection;
using System.Text;
using Astora.Core.Attributes;
using Astora.Core.Nodes;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Astora.Core.Utils;

/// <summary>
/// Generates C# source code (IScene implementation) from a Node tree.
/// Output uses SceneBuilder fluent API to clearly express the node hierarchy.
/// </summary>
public class SceneCodeEmitter
{
    /// <summary>
    /// Properties that should never be emitted (runtime-only or structural).
    /// </summary>
    private static readonly HashSet<string> IgnoredPropertyNames = new()
    {
        "Parent",
        "Children",
        "IsQueuedForDeletion",
        "GlobalTransform",
        "GlobalPosition",
        // Runtime-only properties
        "Texture",
        "Effect",
        "BlendState",
        // AnimatedSprite runtime
        "Frames",
        "Playing",
        "Animation",
        "Frame",
    };

    /// <summary>
    /// Cache of default instances per node type, used to compare property values.
    /// </summary>
    private readonly Dictionary<Type, Node> _defaultInstances = new();

    /// <summary>
    /// Emit a complete IScene C# source file from a Node tree using SceneBuilder syntax.
    /// </summary>
    public string Emit(Node root, string namespaceName, string className, string scenePath)
    {
        var sb = new StringBuilder();
        var usings = new HashSet<string>
        {
            "Astora.Core.Nodes",
            "Astora.Core.Scene",
            "Microsoft.Xna.Framework"
        };

        CollectUsings(root, usings);

        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Generated by Astora Editor. Do not modify manually.");
        sb.AppendLine("// Regenerate by saving the scene in the editor.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();

        foreach (var u in usings.OrderBy(x => x))
        {
            sb.AppendLine($"using {u};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {className} : IScene");
        sb.AppendLine("{");
        sb.AppendLine($"    public static string ScenePath => \"{EscapeString(scenePath)}\";");
        sb.AppendLine();
        sb.AppendLine("    public static Node Build()");
        sb.AppendLine("    {");

        // SceneBuilder chain
        var rootType = root.GetType().Name;
        var chainIndent = "            "; // 12 spaces — method chain continuation level
        var rootProps = GetNonDefaultProperties(root);

        sb.AppendLine($"        var root = SceneBuilder.Create<{rootType}>(\"{EscapeString(root.Name)}\")");

        // Root properties via .Configure
        if (rootProps.Count > 0)
        {
            EmitConfigure(sb, rootType, rootProps, chainIndent);
        }

        // Children
        EmitBuilderChildren(sb, root, chainIndent);

        // .Build()
        sb.AppendLine($"{chainIndent}.Build();");

        sb.AppendLine();
        sb.AppendLine("        OnBuild(root);");
        sb.AppendLine("        return root;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    static partial void OnBuild(Node root);");
        sb.AppendLine("}");

        return sb.ToString();
    }

    // ────────────────── Builder emission helpers ──────────────────

    /// <summary>
    /// Emit a .Configure&lt;T&gt;(n =&gt; { … }) call for property assignments.
    /// </summary>
    private void EmitConfigure(StringBuilder sb, string typeName,
        List<(string PropName, string Literal)> props, string indent)
    {
        sb.AppendLine($"{indent}.Configure<{typeName}>(n =>");
        sb.AppendLine($"{indent}{{");
        foreach (var (propName, literal) in props)
        {
            sb.AppendLine($"{indent}    n.{propName} = {literal};");
        }
        sb.AppendLine($"{indent}}})");
    }

    /// <summary>
    /// Recursively emit child nodes as SceneBuilder method chain calls.
    /// <list type="bullet">
    ///   <item>Leaf without props  → <c>.Add&lt;T&gt;("Name")</c></item>
    ///   <item>Leaf with props     → <c>.Add&lt;T&gt;("Name", n =&gt; { … })</c></item>
    ///   <item>Branch without props → <c>.AddChild&lt;T&gt;("Name", b =&gt; b …)</c></item>
    ///   <item>Branch with props   → <c>.AddChild&lt;T&gt;("Name", b =&gt; b.Configure&lt;T&gt;(…) …)</c></item>
    /// </list>
    /// </summary>
    private void EmitBuilderChildren(StringBuilder sb, Node parent, string chainIndent)
    {
        foreach (var child in parent.Children)
        {
            var typeName = child.GetType().Name;
            var name = EscapeString(child.Name);
            var props = GetNonDefaultProperties(child);
            var hasChildren = child.Children.Count > 0;
            var hasProps = props.Count > 0;

            if (!hasChildren && !hasProps)
            {
                // .Add<Type>("Name")
                sb.AppendLine($"{chainIndent}.Add<{typeName}>(\"{name}\")");
            }
            else if (!hasChildren && hasProps)
            {
                // .Add<Type>("Name", n =>
                // {
                //     n.Prop = val;
                // })
                sb.AppendLine($"{chainIndent}.Add<{typeName}>(\"{name}\", n =>");
                sb.AppendLine($"{chainIndent}{{");
                foreach (var (propName, literal) in props)
                {
                    sb.AppendLine($"{chainIndent}    n.{propName} = {literal};");
                }
                sb.AppendLine($"{chainIndent}}})");
            }
            else if (hasChildren && !hasProps)
            {
                // .AddChild<Type>("Name", b => b
                //     .ChildCalls()
                // )
                sb.AppendLine($"{chainIndent}.AddChild<{typeName}>(\"{name}\", b => b");
                EmitBuilderChildren(sb, child, chainIndent + "    ");
                sb.AppendLine($"{chainIndent})");
            }
            else // hasChildren && hasProps
            {
                // .AddChild<Type>("Name", b => b
                //     .Configure<Type>(n =>
                //     {
                //         n.Prop = val;
                //     })
                //     .ChildCalls()
                // )
                var innerIndent = chainIndent + "    ";
                sb.AppendLine($"{chainIndent}.AddChild<{typeName}>(\"{name}\", b => b");
                EmitConfigure(sb, typeName, props, innerIndent);
                EmitBuilderChildren(sb, child, innerIndent);
                sb.AppendLine($"{chainIndent})");
            }
        }
    }

    // ────────────────── Property collection ──────────────────

    /// <summary>
    /// Get a list of non-default property names and their C# literal values for a node.
    /// </summary>
    private List<(string PropName, string Literal)> GetNonDefaultProperties(Node node)
    {
        var result = new List<(string, string)>();
        var defaultNode = GetDefaultInstance(node.GetType());

        foreach (var prop in GetEmittableProperties(node.GetType()))
        {
            if (prop.Name == "Name") continue;

            try
            {
                var currentValue = prop.GetValue(node);
                var defaultValue = defaultNode != null ? prop.GetValue(defaultNode) : null;

                if (!ValuesEqual(currentValue, defaultValue, prop.PropertyType))
                {
                    var literal = ToLiteral(currentValue, prop.PropertyType, prop);
                    if (literal != null)
                    {
                        result.Add((prop.Name, literal));
                    }
                }
            }
            catch
            {
                // Skip properties that throw on access
            }
        }

        return result;
    }

    // ────────────────── Using collection ──────────────────

    private void CollectUsings(Node node, HashSet<string> usings)
    {
        var ns = node.GetType().Namespace;
        if (!string.IsNullOrEmpty(ns))
            usings.Add(ns);

        foreach (var prop in GetEmittableProperties(node.GetType()))
        {
            if (prop.PropertyType == typeof(Color) || prop.PropertyType == typeof(Rectangle))
                usings.Add("Microsoft.Xna.Framework");
        }

        foreach (var child in node.Children)
            CollectUsings(child, usings);
    }

    // ────────────────── Property helpers ──────────────────

    private IEnumerable<PropertyInfo> GetEmittableProperties(Type nodeType)
    {
        return nodeType.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p =>
                p.CanRead &&
                p.CanWrite &&
                p.GetIndexParameters().Length == 0 &&
                !IgnoredPropertyNames.Contains(p.Name) &&
                IsEmittableType(p.PropertyType));
    }

    private static bool IsEmittableType(Type type)
    {
        if (type == typeof(float) || type == typeof(double) || type == typeof(int) ||
            type == typeof(bool) || type == typeof(string))
            return true;

        if (type == typeof(Vector2) || type == typeof(Color) || type == typeof(Rectangle))
            return true;

        if (type == typeof(Rectangle?))
            return true;

        if (type.IsEnum)
            return true;

        return false;
    }

    // ────────────────── Literal conversion ──────────────────

    private string? ToLiteral(object? value, Type type, PropertyInfo prop)
    {
        if (value == null)
            return "null";

        if (type == typeof(float))
            return $"{(float)value:G}f";

        if (type == typeof(double))
            return $"{(double)value:G}d";

        if (type == typeof(int))
            return ((int)value).ToString();

        if (type == typeof(bool))
            return (bool)value ? "true" : "false";

        if (type == typeof(string))
        {
            var strValue = (string)value;

            if (HasContentRelativePathAttribute(prop))
                strValue = ToContentRelativePath(strValue);

            return $"\"{EscapeString(strValue)}\"";
        }

        if (type == typeof(Vector2))
        {
            var vec = (Vector2)value;
            return $"new Vector2({vec.X:G}f, {vec.Y:G}f)";
        }

        if (type == typeof(Color))
        {
            var color = (Color)value;
            return $"new Color({color.R}, {color.G}, {color.B}, {color.A})";
        }

        if (type == typeof(Rectangle))
        {
            var rect = (Rectangle)value;
            return $"new Rectangle({rect.X}, {rect.Y}, {rect.Width}, {rect.Height})";
        }

        if (type == typeof(Rectangle?))
        {
            if (value is Rectangle rect)
                return $"new Rectangle({rect.X}, {rect.Y}, {rect.Width}, {rect.Height})";
            return "null";
        }

        if (type.IsEnum)
            return $"{type.Name}.{value}";

        return null;
    }

    // ────────────────── Value comparison ──────────────────

    private static bool ValuesEqual(object? a, object? b, Type type)
    {
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;

        if (type == typeof(float))
            return Math.Abs((float)a - (float)b) < 1e-6f;

        if (type == typeof(double))
            return Math.Abs((double)a - (double)b) < 1e-10;

        if (type == typeof(Vector2))
        {
            var va = (Vector2)a;
            var vb = (Vector2)b;
            return Math.Abs(va.X - vb.X) < 1e-6f && Math.Abs(va.Y - vb.Y) < 1e-6f;
        }

        return a.Equals(b);
    }

    // ────────────────── Default instances ──────────────────

    private Node? GetDefaultInstance(Type nodeType)
    {
        if (_defaultInstances.TryGetValue(nodeType, out var cached))
            return cached;

        try
        {
            var ctor = nodeType.GetConstructor(new[] { typeof(string) });
            if (ctor != null)
            {
                var instance = (Node)ctor.Invoke(new object[] { "__default__" });
                _defaultInstances[nodeType] = instance;
                return instance;
            }

            ctor = nodeType.GetConstructor(Type.EmptyTypes);
            if (ctor != null)
            {
                var instance = (Node)ctor.Invoke(null);
                _defaultInstances[nodeType] = instance;
                return instance;
            }
        }
        catch
        {
            // Some constructors may fail (e.g. if they need GraphicsDevice)
        }

        _defaultInstances[nodeType] = null!;
        return null;
    }

    // ────────────────── Content path helpers ──────────────────

    private static bool HasContentRelativePathAttribute(PropertyInfo prop)
    {
        var declaringType = prop.DeclaringType;
        if (declaringType == null) return false;

        var camelName = "_" + char.ToLower(prop.Name[0]) + prop.Name.Substring(1);
        var pascalName = "_" + prop.Name;

        var flags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public;
        var field = declaringType.GetField(camelName, flags)
                    ?? declaringType.GetField(pascalName, flags);

        return field != null && field.IsDefined(typeof(ContentRelativePathAttribute), false);
    }

    private static string ToContentRelativePath(string path)
    {
        if (string.IsNullOrEmpty(path) || !Path.IsPathRooted(path))
            return path;

        try
        {
            var contentRoot = Engine.Content.RootDirectory;
            if (string.IsNullOrEmpty(contentRoot))
                return path;

            var fullContentRoot = Path.GetFullPath(contentRoot);
            var fullPath = Path.GetFullPath(path);

            if (!fullContentRoot.EndsWith(Path.DirectorySeparatorChar))
                fullContentRoot += Path.DirectorySeparatorChar;

            if (fullPath.StartsWith(fullContentRoot, StringComparison.OrdinalIgnoreCase))
                return fullPath.Substring(fullContentRoot.Length);
        }
        catch
        {
            // If anything goes wrong, return the original path
        }

        return path;
    }

    // ────────────────── String helpers ──────────────────

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
